use anyhow::Result;
use futures::stream::StreamExt;
use std::{collections::HashMap, time::Duration};
use tonic::transport::ClientTlsConfig;
use tracing::{error, info, warn};
use yellowstone_grpc_client::GeyserGrpcClient;
use yellowstone_grpc_proto::prelude::{
    subscribe_update::UpdateOneof, CommitmentLevel, SubscribeRequest,
    SubscribeRequestFilterTransactions, SubscribeUpdate,
};

use crate::config::{GrpcConfig, MonitorConfig};
use crate::transfer_parser::TransferParser;
use crate::address_extractor::AddressExtractor;
use crate::database::{DatabaseManager, SignatureTransactionData, ExtractedAddresses};
use crate::database::signature_storage::{SolTransfer, TokenTransfer};

/// Solana gRPC ÂÆ¢Êà∑Á´Ø
pub struct SolanaGrpcClient {
    grpc_config: GrpcConfig,
    monitor_config: MonitorConfig,
    db_manager: Option<DatabaseManager>,
}

impl SolanaGrpcClient {
    /// ÂàõÂª∫Êñ∞ÁöÑ gRPC ÂÆ¢Êà∑Á´Ø
    pub fn new(grpc_config: GrpcConfig, monitor_config: MonitorConfig) -> Self {
        Self {
            grpc_config,
            monitor_config,
            db_manager: None,
        }
    }

    /// ÂàõÂª∫Â∏¶Êï∞ÊçÆÂ∫ìÁÆ°ÁêÜÂô®ÁöÑ gRPC ÂÆ¢Êà∑Á´Ø
    pub fn with_database(grpc_config: GrpcConfig, monitor_config: MonitorConfig, db_manager: DatabaseManager) -> Self {
        Self {
            grpc_config,
            monitor_config,
            db_manager: Some(db_manager),
        }
    }

    /// ÂºÄÂßãÁõëÂê¨Âπ∂ÊâìÂç∞ gRPC Êï∞ÊçÆ
    pub async fn start_monitoring(&self) -> Result<()> {
        info!("üöÄ ÂºÄÂßãÂêØÂä® Solana gRPC ÂÆ¢Êà∑Á´Ø");
        info!("üìù ÈÖçÁΩÆ‰ø°ÊÅØ:");
        info!("  - gRPC Á´ØÁÇπ: {}", self.grpc_config.endpoint);
        info!("  - ËøûÊé•Ë∂ÖÊó∂: {}Áßí", self.grpc_config.connect_timeout);
        info!("  - ËØ∑Ê±ÇË∂ÖÊó∂: {}Áßí", self.grpc_config.timeout);
        info!("  - ÂåÖÂê´Â§±Ë¥•‰∫§Êòì: {}", self.monitor_config.include_failed_transactions);
        info!("  - ÂåÖÂê´ÊäïÁ•®‰∫§Êòì: {}", self.monitor_config.include_vote_transactions);


        loop {
            match self.connect_and_subscribe().await {
                Ok(_) => {
                    info!("üîÑ ËøûÊé•Êñ≠ÂºÄÔºåÂáÜÂ§áÈáçËøû...");
                }
                Err(e) => {
                    error!("‚ùå ËøûÊé•Â§±Ë¥•: {}", e);
                    info!("‚è∞ 5ÁßíÂêéÈáçËØï...");
                    tokio::time::sleep(Duration::from_secs(5)).await;
                }
            }
        }
    }

    /// Â∞ùËØïËøûÊé•Âπ∂ËÆ¢ÈòÖÊï∞ÊçÆ
    async fn connect_and_subscribe(&self) -> Result<()> {
        info!("üîó Ê≠£Âú®ËøûÊé•Âà∞ gRPC Á´ØÁÇπ: {}", self.grpc_config.endpoint);

        // ÈÖçÁΩÆ TLS
        let tls_config = ClientTlsConfig::new().with_native_roots();

        // ÂàõÂª∫ËÆ¢ÈòÖËØ∑Ê±Ç - ‰øÆÊîπ‰∏∫Êõ¥ÁÆÄÂçïÁöÑÈÖçÁΩÆÊù•Ëé∑ÂèñÊõ¥Â§öÊï∞ÊçÆ
        let subscribe_request = SubscribeRequest {
            accounts: HashMap::new(),
            slots: HashMap::from([(
                "slot".to_string(),
                yellowstone_grpc_proto::prelude::SubscribeRequestFilterSlots {
                    filter_by_commitment: Some(true),
                    interslot_updates: Some(false),
                },
            )]),
            transactions: HashMap::from([(
                "txn".to_string(),
                SubscribeRequestFilterTransactions {
                    vote: Some(false), // ‰∏çÂåÖÂê´ÊäïÁ•®‰∫§Êòì‰ª•ÂáèÂ∞ëÂô™Èü≥
                    failed: Some(false), // ‰∏çÂåÖÂê´Â§±Ë¥•‰∫§Êòì
                    signature: None,
                    account_include: vec![], // ÁßªÈô§ÁâπÂÆöË¥¶Êà∑ÈôêÂà∂‰ª•Ëé∑ÂèñÊõ¥Â§ö‰∫§Êòì
                    account_exclude: vec![],
                    account_required: vec![],
                },
            )]),
            transactions_status: HashMap::new(),
            blocks: HashMap::new(),
            blocks_meta: HashMap::new(),
            entry: HashMap::new(),
            accounts_data_slice: vec![],
            commitment: Some(CommitmentLevel::Processed as i32),
            from_slot: None,
            ping: None,
        };

        info!("‚úÖ ÊàêÂäüËøûÊé•Âà∞ gRPC ÊúçÂä°Âô®ÔºåÂºÄÂßãËÆ¢ÈòÖÊï∞ÊçÆ...");

        // Âª∫Á´ãËøûÊé•Âπ∂ËÆ¢ÈòÖ
        let mut stream = GeyserGrpcClient::build_from_shared(self.grpc_config.endpoint.clone())?
            .tls_config(tls_config)?
            .timeout(Duration::from_secs(self.grpc_config.timeout))
            .connect_timeout(Duration::from_secs(self.grpc_config.connect_timeout))
            .connect()
            .await?
            .subscribe_once(subscribe_request)
            .await?;

        info!("üì° ÂºÄÂßãÁõëÂê¨ Solana Êï∞ÊçÆÊµÅ...");
        let mut message_count = 0u64;
        let mut transaction_count = 0u64;

        while let Some(message) = stream.next().await {
            match message {
                Ok(update) => {
                    message_count += 1;
                    self.handle_update(update, &mut transaction_count, &mut message_count)
                        .await?;
                }
                Err(e) => {
                    error!("‚ùå Êé•Êî∂Ê∂àÊÅØÊó∂Âá∫Èîô: {:?}", e);
                    return Err(e.into());
                }
            }
        }

        Ok(())
    }

    /// Â§ÑÁêÜÊé•Êî∂Âà∞ÁöÑÊõ¥Êñ∞Ê∂àÊÅØ
    async fn handle_update(
        &self,
        update: SubscribeUpdate,
        transaction_count: &mut u64,
        message_count: &mut u64,
    ) -> Result<()> {
        // ÊØè1000Êù°Ê∂àÊÅØÊâìÂç∞‰∏ÄÊ¨°ÁªüËÆ°
        if *message_count % 1000 == 0 {
            info!("üìä Â∑≤Â§ÑÁêÜ {} Êù°Ê∂àÊÅØÔºåÂÖ∂‰∏≠ {} Êù°‰∫§Êòì", message_count, transaction_count);
        }

        match update.update_oneof {
            Some(UpdateOneof::Transaction(transaction_update)) => {
                *transaction_count += 1;
                self.print_transaction_info(&transaction_update, *transaction_count);
                
                // Ëé∑ÂèñÊó∂Èó¥Êà≥
                let timestamp = update.created_at
                    .as_ref()
                    .map(|ts| ts.seconds as u32)
                    .unwrap_or_else(|| std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as u32);
                    
                // Ëß£ÊûêSOLËΩ¨Ë¥¶
                self.parse_and_print_transfers(&transaction_update, timestamp);
                
                // ÊèêÂèñÂπ∂ÊâìÂç∞ÊâÄÊúâÁõ∏ÂÖ≥Âú∞ÂùÄ
                self.extract_and_print_addresses(&transaction_update);

                // Â¶ÇÊûúÊúâÊï∞ÊçÆÂ∫ìÁÆ°ÁêÜÂô®ÔºåÂ≠òÂÇ®‰∫§ÊòìÊï∞ÊçÆ
                if let Some(ref db_manager) = self.db_manager {
                    if let Err(e) = self.store_transaction_to_database(db_manager, &transaction_update, timestamp as i64).await {
                        error!("‚ùå Â≠òÂÇ®‰∫§ÊòìÊï∞ÊçÆÂà∞Êï∞ÊçÆÂ∫ìÂ§±Ë¥•: {}", e);
                    }
                }
            }
            Some(UpdateOneof::Account(account_update)) => {
                self.print_account_info(&account_update);
            }
            Some(UpdateOneof::Slot(slot_update)) => {
                self.print_slot_info(&slot_update);
            }
            Some(UpdateOneof::Block(block_update)) => {
                self.print_block_info(&block_update);
            }
            Some(UpdateOneof::Ping(_)) => {
                // info!("üèì Êî∂Âà∞ Ping Ê∂àÊÅØ");
            }
            Some(UpdateOneof::Pong(_)) => {
                // info!("üèì Êî∂Âà∞ Pong Ê∂àÊÅØ");
            }
            Some(UpdateOneof::BlockMeta(block_meta)) => {
                self.print_block_meta_info(&block_meta);
            }
            Some(UpdateOneof::Entry(entry_update)) => {
                self.print_entry_info(&entry_update);
            }
            Some(UpdateOneof::TransactionStatus(tx_status)) => {
                self.print_transaction_status_info(&tx_status);
            }
            None => {
                warn!("‚ö†Ô∏è Êî∂Âà∞Á©∫Ê∂àÊÅØ");
            }
        }

        Ok(())
    }

    /// ÊâìÂç∞‰∫§Êòì‰ø°ÊÅØ
    fn print_transaction_info(
        &self,
        transaction_update: &yellowstone_grpc_proto::prelude::SubscribeUpdateTransaction,
        _count: u64,
    ) {
        // info!("üí∞ ‰∫§Êòì #{} - ÊßΩ‰Ωç: {}", count, transaction_update.slot);
        
        if let Some(tx) = &transaction_update.transaction {
            let signature = bs58::encode(&tx.signature).into_string();
            info!("üìù Á≠æÂêç: {}", &signature);
            
            // if let Some(meta) = &tx.meta {
            //     if let Some(err) = &meta.err {
            //         info!("   ‚ùå ÈîôËØØ: {:?}", err);
            //     } else {
            //         info!("   ‚úÖ ÊâßË°åÊàêÂäü");
            //     }
                
            //     if let Some(compute_units) = meta.compute_units_consumed {
            //         info!("   üîß ËÆ°ÁÆóÂçïÂÖÉÊ∂àËÄó: {}", compute_units);
            //     }
                
            //     info!("   üí∏ ÊâãÁª≠Ë¥π: {} lamports", meta.fee);
                
            //     // ÊâìÂç∞ÊâÄÊúâË¥¶Êà∑‰ΩôÈ¢ù‰ø°ÊÅØ
            //     if !meta.pre_balances.is_empty() {
            //         info!("   üí∞ Ë¥¶Êà∑‰ΩôÈ¢ù‰ø°ÊÅØ:");
            //         info!("     ÊâßË°åÂâç‰ΩôÈ¢ù (pre_balances): {:?}", meta.pre_balances);
            //         if !meta.post_balances.is_empty() {
            //             info!("     ÊâßË°åÂêé‰ΩôÈ¢ù (post_balances): {:?}", meta.post_balances);
            //             info!("     ‰ΩôÈ¢ùÂèòÂåñ:");
            //             for (i, (pre, post)) in meta.pre_balances.iter().zip(meta.post_balances.iter()).enumerate() {
            //                 if pre != post {
            //                     let change = *post as i64 - *pre as i64;
            //                     let sol_change = change as f64 / 1_000_000_000.0;
            //                     info!("       Ë¥¶Êà∑ {}: {} -> {} lamports (ÂèòÂåñ: {} lamports / {:.9} SOL)", 
            //                           i, pre, post, change, sol_change);
            //                 }
            //             }
            //         }
            //     }
            // }
        }
        // println!(); // Á©∫Ë°åÂàÜÈöî
    }

    /// ÊâìÂç∞Ë¥¶Êà∑‰ø°ÊÅØ
    fn print_account_info(
        &self,
        account_update: &yellowstone_grpc_proto::prelude::SubscribeUpdateAccount,
    ) {
        if let Some(account) = &account_update.account {
            let pubkey = bs58::encode(&account.pubkey).into_string();
            info!("üë§ Ë¥¶Êà∑Êõ¥Êñ∞ - Âú∞ÂùÄ: {}", pubkey);
            info!("   üìç ÊßΩ‰Ωç: {}", account_update.slot);
            info!("   üí∞ ‰ΩôÈ¢ù: {} lamports", account.lamports);
            info!("   üëë ÊâÄÊúâËÄÖ: {}", bs58::encode(&account.owner).into_string());
            info!("   üìä Êï∞ÊçÆÈïøÂ∫¶: {} bytes", account.data.len());
        }
    }

    /// ÊâìÂç∞ÊßΩ‰Ωç‰ø°ÊÅØ
    fn print_slot_info(&self, slot_update: &yellowstone_grpc_proto::prelude::SubscribeUpdateSlot) {
        info!("üéØ ÊßΩ‰ΩçÊõ¥Êñ∞ - ÊßΩ‰Ωç: {}", slot_update.slot);
        info!("   üìà Áä∂ÊÄÅ: {:?}", slot_update.status());
        if let Some(parent) = slot_update.parent {
            info!("   üëÜ Áà∂ÊßΩ‰Ωç: {}", parent);
        }
    }

    /// ÊâìÂç∞Âå∫Âùó‰ø°ÊÅØ
    fn print_block_info(&self, block_update: &yellowstone_grpc_proto::prelude::SubscribeUpdateBlock) {
        info!("üß± Âå∫ÂùóÊõ¥Êñ∞ - ÊßΩ‰Ωç: {}", block_update.slot);
        info!("   üîó Âå∫ÂùóÂìàÂ∏å: {}", bs58::encode(&block_update.blockhash).into_string());
        info!("   üìä ‰∫§ÊòìÊï∞Èáè: {}", block_update.transactions.len());
        info!("   ‚è∞ Âå∫ÂùóÊó∂Èó¥: {:?}", block_update.block_time);
    }

    /// ÊâìÂç∞Âå∫ÂùóÂÖÉÊï∞ÊçÆ‰ø°ÊÅØ
    fn print_block_meta_info(
        &self,
        block_meta: &yellowstone_grpc_proto::prelude::SubscribeUpdateBlockMeta,
    ) {
        info!("üìã Âå∫ÂùóÂÖÉÊï∞ÊçÆ - ÊßΩ‰Ωç: {}", block_meta.slot);
        info!("   üîó Âå∫ÂùóÂìàÂ∏å: {}", bs58::encode(&block_meta.blockhash).into_string());
        info!("   ‚è∞ Âå∫ÂùóÊó∂Èó¥: {:?}", block_meta.block_time);
    }

    /// ÊâìÂç∞Êù°ÁõÆ‰ø°ÊÅØ
    fn print_entry_info(&self, entry_update: &yellowstone_grpc_proto::prelude::SubscribeUpdateEntry) {
        info!("üìù Êù°ÁõÆÊõ¥Êñ∞ - ÊßΩ‰Ωç: {}", entry_update.slot);
        info!("   üÜî Á¥¢Âºï: {}", entry_update.index);
        info!("   üìä ‰∫§ÊòìÊï∞Èáè: {}", entry_update.num_hashes);
        info!("   üîó ÂìàÂ∏å: {}", bs58::encode(&entry_update.hash).into_string());
    }

    /// ÊâìÂç∞‰∫§ÊòìÁä∂ÊÄÅ‰ø°ÊÅØ
    fn print_transaction_status_info(
        &self,
        tx_status: &yellowstone_grpc_proto::prelude::SubscribeUpdateTransactionStatus,
    ) {
        let signature = bs58::encode(&tx_status.signature).into_string();
        info!("üîç ‰∫§ÊòìÁä∂ÊÄÅ - Á≠æÂêç: {}", &signature[..32]);
        info!("   üìç ÊßΩ‰Ωç: {}", tx_status.slot);
        info!("   üìã Á¥¢Âºï: {}", tx_status.index);
        if let Some(err) = &tx_status.err {
            info!("   ‚ùå ÈîôËØØ: {:?}", err);
        } else {
            info!("   ‚úÖ ÊâßË°åÊàêÂäü");
        }
    }

    /// Ëß£ÊûêÂπ∂ÊâìÂç∞ËΩ¨Ë¥¶‰ø°ÊÅØ
    fn parse_and_print_transfers(&self, transaction_update: &yellowstone_grpc_proto::prelude::SubscribeUpdateTransaction, timestamp: u32) {
        // Ëß£ÊûêSOLËΩ¨Ë¥¶
        match TransferParser::parse_sol_transfers(transaction_update, timestamp) {
            Ok(sol_transfers) => {
                if !sol_transfers.is_empty() {
                    TransferParser::print_transfers(&sol_transfers);
                    
                    // // ÁªüËÆ°‰ø°ÊÅØ
                    // let total_amount = TransferParser::get_total_transfer_amount(&sol_transfers);
                    // let sol_amount = total_amount as f64 / 1_000_000_000.0;
                    // info!("   üìä SOLËΩ¨Ë¥¶ÊÄªÈáëÈ¢ù: {:.6} SOL ({} lamports)", sol_amount, total_amount);
                    
                    // // Ê£ÄÊü•ÊòØÂê¶ÊúâÂ§ßÈ¢ùËΩ¨Ë¥¶
                    // if TransferParser::has_large_transfer(&sol_transfers, 10.0) {
                    //     info!("   üî• ÂåÖÂê´10+ SOLÁöÑÂ§ßÈ¢ùËΩ¨Ë¥¶ÔºÅ");
                    // }
                }
            }
            Err(e) => {
                warn!("Ëß£ÊûêSOLËΩ¨Ë¥¶Êó∂Âá∫Èîô: {}", e);
            }
        }

        // Ëß£Êûê‰ª£Â∏ÅËΩ¨Ë¥¶
        match TransferParser::parse_token_transfers(transaction_update, timestamp) {
            Ok(token_transfers) => {
                if !token_transfers.is_empty() {
                    TransferParser::print_token_transfers(&token_transfers);
                    
                    // // ÁªüËÆ°‰ø°ÊÅØ
                    // let token_count = TransferParser::get_total_token_transfer_count(&token_transfers);
                    // info!("   üìä ‰ª£Â∏ÅËΩ¨Ë¥¶ÊÄªÊï∞: {} Á¨î", token_count);
                    
                    // // Êåâ‰ª£Â∏ÅÂàÜÁªÑÁªüËÆ°
                    // let grouped = TransferParser::group_token_transfers_by_mint(&token_transfers);
                    // if grouped.len() > 1 {
                    //     info!("   üè∑Ô∏è  Ê∂âÂèä {} Áßç‰∏çÂêå‰ª£Â∏Å", grouped.len());
                    //     for (mint, mint_transfers) in &grouped {
                    //         info!("     ‰ª£Â∏Å {}: {} Á¨îËΩ¨Ë¥¶", &mint[..8], mint_transfers.len());
                    //     }
                    // }
                }
            }
            Err(e) => {
                warn!("Ëß£Êûê‰ª£Â∏ÅËΩ¨Ë¥¶Êó∂Âá∫Èîô: {}", e);
            }
        }
    }

    /// ÊèêÂèñÂπ∂ÊâìÂç∞‰∫§Êòì‰∏≠ÁöÑÊâÄÊúâÁõ∏ÂÖ≥Âú∞ÂùÄ
    fn extract_and_print_addresses(&self, transaction_update: &yellowstone_grpc_proto::prelude::SubscribeUpdateTransaction) {
        match AddressExtractor::extract_all_addresses(transaction_update) {
            Ok(addresses) => {
                if !addresses.is_empty() {
                    info!("üîç ‰∫§ÊòìÂú∞ÂùÄÂàóË°® ({} ‰∏™):", addresses.len());
                    for (i, address) in addresses.iter().enumerate() {
                        info!("   {}. {}", i + 1, address);
                    }
                    println!(); // Á©∫Ë°åÂàÜÈöî‰∏çÂêå‰∫§Êòì
                }
            }
            Err(e) => {
                warn!("ÊèêÂèñÂú∞ÂùÄÊó∂Âá∫Èîô: {}", e);
            }
        }
    }

    /// Â∞Ü‰∫§ÊòìÊï∞ÊçÆÂ≠òÂÇ®Âà∞Êï∞ÊçÆÂ∫ì
    async fn store_transaction_to_database(
        &self,
        db_manager: &DatabaseManager,
        transaction_update: &yellowstone_grpc_proto::prelude::SubscribeUpdateTransaction,
        timestamp: i64,
    ) -> Result<()> {
        let transaction = match &transaction_update.transaction {
            Some(tx) => tx,
            None => {
                warn!("‰∫§ÊòìÊï∞ÊçÆ‰∏∫Á©∫ÔºåË∑≥ËøáÂ≠òÂÇ®");
                return Ok(());
            }
        };

        // Ëé∑Âèñ‰∫§ÊòìÁ≠æÂêç
        let signature = bs58::encode(&transaction.signature).into_string();

        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
        if let Ok(exists) = db_manager.signature_storage().signature_exists(&signature) {
            if exists {
                // ‰∫§ÊòìÂ∑≤Â≠òÂú®ÔºåË∑≥Ëøá
                return Ok(());
            }
        }

        // ÂàõÂª∫Á≠æÂêç‰∫§ÊòìÊï∞ÊçÆ
        let mut signature_data = SignatureTransactionData::new(
            signature.clone(),
            timestamp,
            transaction_update.slot,
            transaction_update.transaction.as_ref()
                .and_then(|tx| tx.meta.as_ref())
                .map(|meta| meta.err.is_none())
                .unwrap_or(false),
        );

        // Ëß£Êûê SOL ËΩ¨Ë¥¶
        if let Ok(sol_transfers) = TransferParser::parse_sol_transfers(transaction_update, timestamp as u32) {
            for transfer in sol_transfers {
                signature_data.add_sol_transfer(SolTransfer {
                    from: transfer.from,
                    to: transfer.to,
                    amount: transfer.amount,
                    transfer_type: "SOL Transfer".to_string(),
                });
            }
        }

        // Ëß£Êûê‰ª£Â∏ÅËΩ¨Ë¥¶
        let mut parsed_token_transfers = Vec::new();
        if let Ok(token_transfers) = TransferParser::parse_token_transfers(transaction_update, timestamp as u32) {
            for transfer in token_transfers {
                let token_transfer = TokenTransfer {
                    from: transfer.from.clone(),
                    to: transfer.to.clone(),
                    amount: transfer.amount,
                    decimals: transfer.decimals as u8,
                    mint: transfer.mint.clone(),
                    program_id: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA".to_string(),
                    transfer_type: "Token Transfer".to_string(),
                };
                signature_data.add_token_transfer(token_transfer.clone());
                
                // ‰∏∫Âú∞ÂùÄÂ≠òÂÇ®ÂàõÂª∫Â∏¶ÊúâÂÆåÊï¥Â≠óÊÆµÁöÑtransfer_parser::TokenTransfer
                let parser_token_transfer = crate::transfer_parser::TokenTransfer {
                    signature: signature.clone(),
                    from: transfer.from,
                    to: transfer.to,
                    amount: transfer.amount,
                    mint: transfer.mint,
                    decimals: transfer.decimals,
                    timestamp: timestamp as u32,
                    program_id: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA".to_string(),
                    transfer_type: "Token Transfer".to_string(),
                };
                parsed_token_transfers.push(parser_token_transfer);
            }
        }

        // ÊèêÂèñÂú∞ÂùÄ‰ø°ÊÅØ
        if let Ok(addresses) = AddressExtractor::extract_all_addresses(transaction_update) {
            let extracted_addresses = ExtractedAddresses {
                all_addresses: addresses,
            };
            signature_data.set_extracted_addresses(extracted_addresses);
        }

        // Â≠òÂÇ®Âà∞Á≠æÂêçÊï∞ÊçÆÂ∫ì
        match db_manager.signature_storage().store_signature_data(&signature, &signature_data) {
            Ok(_) => {
                info!("üíæ ÊàêÂäüÂ≠òÂÇ®‰∫§Êòì {} Âà∞Á≠æÂêçÊï∞ÊçÆÂ∫ì", &signature[..8]);
            }
            Err(e) => {
                error!("‚ùå Â≠òÂÇ®‰∫§Êòì {} Âà∞Á≠æÂêçÊï∞ÊçÆÂ∫ìÂ§±Ë¥•: {}", &signature[..8], e);
                return Err(e);
            }
        }

        // ÂêåÊó∂Â≠òÂÇ®Âà∞Âú∞ÂùÄÊï∞ÊçÆÂ∫ì
        let parsed_sol_transfers: Vec<crate::transfer_parser::SolTransfer> = signature_data.sol_transfers.iter().map(|st| {
            crate::transfer_parser::SolTransfer {
                signature: signature.clone(),
                from: st.from.clone(),
                to: st.to.clone(),
                from_index: 0, // Ëøô‰∫õÂ≠óÊÆµÂú®Âú∞ÂùÄÂ≠òÂÇ®‰∏≠‰∏ç‰ΩøÁî®
                to_index: 0,
                amount: st.amount,
                timestamp: timestamp as u32,
                transfer_type: st.transfer_type.clone(),
            }
        }).collect();

        if let Err(e) = db_manager.address_storage().batch_process_transaction(
            &signature,
            timestamp as u64,
            transaction_update.slot,
            &parsed_sol_transfers,
            &parsed_token_transfers,
        ) {
            error!("‚ùå Â≠òÂÇ®‰∫§Êòì {} Âà∞Âú∞ÂùÄÊï∞ÊçÆÂ∫ìÂ§±Ë¥•: {}", &signature[..8], e);
            // ‰∏çËøîÂõûÈîôËØØÔºåÂõ†‰∏∫‰∏ªË¶ÅÂ≠òÂÇ®Â∑≤ÊàêÂäü
        } else {
            info!("üè† ÊàêÂäüÂ≠òÂÇ®‰∫§Êòì {} Âà∞Âú∞ÂùÄÊï∞ÊçÆÂ∫ì", &signature[..8]);
        }

        Ok(())
    }
} 